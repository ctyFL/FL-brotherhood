计算机的高速缓存：

		前面学到，“高速缓存” 是在 “缓存-主存” 这个层次中

		高速缓存的工作原理：
				1.字：是指存放在一个存储单元中的二进制代码组合，一个 “字” 可以表示一个数据、一个指令、一个字符串
				2.字块：包含了多个字，“多个字” 连续组合成一个 “字块”，存储在连续的存储单元中而被看作是一个单元的 “一组字”

			现在假设一个字有32位，一个字块有8个字，主存中有10个字块，那么主存总容量就为：32*8*10（bits）



		寻址：
		  “字” 的地址包含两个部分
			  前m位指定 “字块” 的地址
			  后b位指定 “字” 在 “字块” 中的地址
				例如： 一个 “字” 的地址为 “xx... yyy...” 
					  其中前m位（xx...）为 “字块” 的地址 
					  后b位（yyy...）为 “字” 的地址

			  那么：“字块” 的地址就有 “2的m次方” 种不同的0/1组合，也就是可以用来表示 “2的m次方” 个 “字块” 的地址，同理，就可以表示 “2的b次方” 个 “字” 的地址
				有公式 M=2的m次方 B=2的b次方 


		 例子：假设主存容量为4G，字块大小为4M，字长为32位，则对于字地址中的块地址m、和块内字地址b的位数，至少应该是多少？
				解：
				1.4G = 4096M
				2.4096 / 4M = 1024 个 （总共可以储存1024个字块）
				3.所以需要1024个0/1组合来表示块地址，2的10次方=1024，所以块地址位数m=10

				4.4M = 33554432bits
				5.33554432bits / 32bits = 1048576 个 （一个字块内可以储存1048576个字）
                6.所以需要1048576个0/1组合来表示块内字地址，2的20次方=1048576，所以字地址位数b=20



		 缓存与主存：
			缓存的结构和主存的结构非常类似，都有 “字” 和 “字块” 的概念
			主存的容量大小（字块数）远大于缓存
			缓存里的数据来自于主存，缓存里的数据就是主存里的数据的复制
			缓存的速度较快

		
		 “高速缓存” 是怎么样在 “缓存-主存” 这个层次中工作呢？
			CPU需要 “高速缓存” 有两种情况：
			1.CPU需要的数据在缓存里，就可以直接的快速的取数据
			2.CPU需要的数据不在缓存里，就需要去主存里拿，然后主存的速度小于缓存，这样就会大大降低CPU的效率（所以要尽可能的去缓存里取数据）
				有一个量化的指标来衡量CPU去缓存里取数据成功的机率—— “命中率”

				命中率:是衡量缓存性能的重要指标，CPU每次都能从缓存中取到数据时，命中率为1（但是缓存容量小于主存，所以永远不可能为1）
					命中率计算公式：(访问缓存次数占总次数的比例)
						访问主存次数：Nm
						访问Cache次数：Nc
						命中率：h = Nc / (Nm + Nc)

				还有一个指标—— "访问效率"
					访问效率计算公式：
						命中率：h 
						访问主存时间：tm
						访问缓存时间：tc
						访问Cache-主存平均时间：ta = h * tc + (1-h) * tm
						访问效率: e = tc / ta


			例子：假设CPU在执行某段程序时，共访问了Cache命中2000次，访问主存50次，已知Cache的存取时间为50ns，主存的存取时间为200ns，求Cache-主存系统的命中率、访问效率和平均访问时间
					解：
					1.命中率：h = 2000 / (2000 + 50) = 0.98
					2.平均时间：ta = 0.98 * 50 + (1 - 0.98) * 200 = 53ns
					3.访问效率：e = 50 / 53 = 0.94


			为了提高CPU效率，也就是使命中率越高越好，也就是尽量让CPU从高速缓存里取数据：
				这个时候就需要一个 “性能良好的缓存替换策略”————使得缓存里面的数据都是CPU所需要的数据




			高速缓存的替换策略：
				高速缓存的替换时机：当CPU所需要的数据不在高速缓存里，这个时候就需要从主存中载入所需数据

				4种策略：
					1.随机算法：每次需要替换数据的时候，随机选取高速缓存里的一个位置，然后把相关数据替换调
					2.先进先出算法（FIFO）：把高速缓存看成一个先进先出的队列，替换新的数据时，就会把最先入队的字块作出队操作，然后把新字块在队尾入队
					3.最不经常使用算法（LFU）：有新数据时，优先把最不经常使用字块替换调，这个时候需要一个额外的空间来记录各个字块的使用频率，然后替换时，找到使用频率最低的个字块和它的位置，把它替换掉
					4.最近最少使用算法（LRU）：一般使用双向链表实现，把正在使用的字块插入到链表头节点（最前面），然后使用另一个字块时，再把另一个字块插入到头节点，以此类推，一旦缓存容量满了，就会把当前位于链表尾部（最后面）的字块替换掉