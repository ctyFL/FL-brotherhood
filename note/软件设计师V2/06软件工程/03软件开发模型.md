软件开发模型：

		软件开发模型有：
					(1)瀑布模型
					(2)增量模型
					(3)螺旋模型
					(4)喷泉模型
					(5)智能模型
					(6)V模型
					(7)快速应用开发模型
					(8)构件组装模型
					(9)敏捷方法
					(10)统一过程



		1.瀑布模型：
				也称 “生命周期法”
				是 “线性的模型”
				是 “结构化方法” 中最常用的开发模型
				它把软件开发的过程分为大的三个阶段：一、定义阶段，二、开发阶段，三、维护阶段
				6个具体阶段：1.软件计划，2.需求分析，3.软件设计，4.程序编码，5.软件测试，6.软件维护：

					一、定义阶段：
								1.软件计划
								2.需求分析
					二、开发阶段：
								3.软件设计
								4.程序编码
								5.软件测试
					三、维护阶段：
								6.软件维护


				瀑布模型优点：
						(1)为项目提高了按阶段划分的 “检查点”：
									各阶段都有一个严格的里程碑，如：需求分析阶段，有一个阶段产物
									（即里程碑）叫做 “需求分析说明书”，我们就要按照这个里程碑去检
									查这个阶段成果是否已经完成了（即评审），完成了才允许继续下一
									个阶段（即通过评审）

						(2)当前一个阶段完成后（即上一个阶段通过了评审后），只需去关注后续阶段

						(3)它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在
						   该模板下有一个共同的指导
						  （相当于有一个工作手册，工作人员只需要按照工作手册去走就可以了）


				瀑布模型缺点：
						(1)各个阶段之间产生大量的文档（如各个阶段里程碑——xx说明书），极大地增加了
						   工作量

						(2)由于开发模型是 “线性” 的，用户只有等到整个过程的末期才能见到开发成果，
						   从而增加了 “开发风险”
						   (如：客户要求一个 “苹果”，由于前期需求分析理解不正确，理解成了 “梨”，
							到了最后的阶段完成，用户才发现不会，我们才发现错误)

						(3)不适应用户需求的变化，并且在需求分析阶段不可能完全获取需求
						  （即需求分析阶段完成后，后面的工作就关注设计、编码等，不再关注需求了，这
							时若用户产生需求变化，对于开发人员是很难响应的，即使用户需求不会变，我
							们也很难一开始在需求分析阶段就完全获取用户需求，因为用户不了解软件
							的，沟通上的偏差）

						(4)软件开发前期未发现的错误传到后面的开发工作中，可能会扩散，进而导致整个
						   软件项目开发失败
						   (如需求发生错误，后面设计、编码等都走歪了)


				瀑布模型适用范围：
						需求明确、很少变更的项目







		2.快速原型模型：
					快速原型是利用 “原型辅助软件” 开发的一种新思想
					经过简单快速分析，快速建造一个可以运行的软件原型，以便理解和澄清问题，使开发人
					员和用户达成共识，最终在 “确定的客户需求基础上” 开发客户满意的软件产品
					（例如小区的沙盘模型，建造一架飞机前的飞机模型）



					原型模型可以分为三类：
						（1）探索型原型：
									主要用于 “需求分析阶段”，目的是弄清用户的需求，并探索各种方案
									的可行性，主要针对开发目标模糊，用户与开发人员对项目都缺乏
									经验的情况，通过对原型的开发来明确用户的需求

						 (2)实验型原型：
									主要用于 “设计阶段”，“设计方案有了”，需要考验实现方案是否合
									适、能否实现，对于大型系统，若对设计方案心中没有把握时，可以
									通过这种原型来证实设计方案的正确性

						（3）演化型原型：
									主要用于及早向用户提交一个 “原型系统”，该原型系统或者包含系统
									的框架， 或者包含系统的主要功能，在得到用户的认可后，将原型系
									统 “不断扩充演变为最终的系统软件” 
									————它将原型的思想扩展到软件开发的全过程				





		3.演化模型：(即前面的演化型原型)
				也称 “变换模型”，根据用户的基本需求，通过快速分析构造出一个初始可运行版本（原型），
				然后根据用户在使用原型的过程中提出的意见和建议对原型 “进行改进”，获得原型的 “新版本”，重复这一过程，最终得到令用户满意的软件产品

				快速原型模型是 “抛弃式” 的，演化模型是 “渐进式” 的
				演化模型特别适用于对软件需求缺乏准确认识的情况


				优点：
					(1)很早就可以验证是否符合产品需求
					(2)风险管理可以在早期就获得项目进程数据，可据此对后续的开发进度作出比较切实的
					   估算，增加项目成功的机率
					(3)经验教训能反馈于本产品的下一个循环过程，提高质量效率
					(4)心理上，开发人员早日见到产品的雏形，是一种鼓舞
					(5)使用户可以在新的一批功能开发测试后，立即参加验证，以便提供非常有价值的反馈

				缺点：
					(1)产品需求在一开始并不完全弄清楚的话，会给总体设计带来困难及削弱产品设计的完整
					   性，并影响产品性能的优化
					(2)若缺乏严格的过程管理，这个生命周期模型可能退化为一种原始的无计划的 
					   “试-错-改” 模式
					(3)用户接触开发中的尚未测试稳定的功能，可能对用户产生负面影响






		4.增量模型：
				融合了 “瀑布模型的基本成分” 和 “原型实现的迭代特征”，是第三种原型化开发方法
				但它不是 “抛弃式” 的，也不是 “渐进式” 的

				增量模型把软件产品划分为一系列的增量构件（即一个个模块）
				第一个增量往往是 “核心” 的产品，即实现了基本的需求，然后后面再增加一个个的模块、功能

				客户对每一个增量的使用、评估都作为下一个增量发布的 “新特征” 和 “新功能”
				这个过程在每一个增量发布后不断重复，直到产生了最终的完善的产品

				增量模型与原型实现模型和其他演化方法一样，本质上是迭代的，但与原型实现不一样的是其
				强调 “每一个增量” 均发布一个 “可操作产品”

				增量模型的特点是引进了 “增量包” 的概念，无须等待到所有需求都出来，只要某个需求的增
				量包出来即可进行开发


				优点：
					(1)人员分配灵活，初期不用太大投入
					(2)每隔一小段时间就提交用户部分功能，用户可以直观感受项目进展，及时试用功能
					(3)有利于风险的把控

				————增量模型将功能细化、分别开发的方法适应 “需求经常改变” 的软件开发过程







		5.螺旋模型：
				将 “瀑布模型” 与 “演化模型” 相结合，综合了两者的优点，并增加了 “风险分析”
				它以 “原型” 为基础，沿着螺线 “自内向外旋转”
				每旋转一圈都要经过：制定计划、风险分析、实施工程及客户评价等活动，并开发原型的一个
				新版本，经过若干次螺旋上升的过程，得到最终的系统


				优点：
					(1)设计上灵活，可以在项目的各个阶段进行变更（如需求、设计等的问题可以及时变更）
					(2)以小的分段来构建大型系统，使成本计算变得简单容易
					(3)客户始终参与每个阶段的开发，保证了项目不偏离正确方向
					(4)随着项目推进，客户始终掌握项目的最新信息，从而能够和管理层有效地交互


				缺点：
					(1)需要具有相当丰富的风险评估经验和专门知识，若为能够及时标识风险，势必造成重大
					   损失
					(2)过多的迭代次数会增加开发成本，延迟交付时间





		6.喷泉模型：
				是以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程，该模型
				认为软件开发过程是 “自下而上” 的，各阶段是相互迭代和无间隙的

				无间隙：指在开发活动中，分析、设计、编码之间不存在明细的边界（不同于瀑布模型存在明显的边界、有一个阶段成果——里程碑）

				自下而上依次为：分析——设计——实现——维护——演化






		7.基于构件的开发模型：
				（现在最流行的方法，现在企业大多做一些行业软件：金融、铁路、环保的等）
				将整个系统模块化，并在一定构件模型的支持下，“复用构件库” 中的一个或多个 “软件构件”
				通过组合手段高效率、高质量地构建应用软件系统
					例如：现在需要一个 “通信模块”，我们可以从第三方中购买过来，加入我们构件库中


				即：我有一个构件库，包含很多软件构件，开发时需要哪个就取哪个，组合到项目中
					因为这个构件之前可能已经用过，所以质量有保证、高效率
	

				构件库建立：不是一下子就建立起来，而是在开发过程中，不断增加、完善软件构件，构件库
						   里的构件越来越丰富，那么下次开发时选择就更多了
 

				5个阶段：需求分析——定义——体系结构设计——构件库建立——应用软件构建、测试、发布



				优点：
					构件复用，提高了软件开发的效率，构件可由一方定义其规格说明，被另一方实现，然后
					供给第三方使用，构件组装模型允许多个项目同时开发，降低了费用，提高了可维护性，
					可实现分步提交软件产品

				缺点：
					缺乏通用的组装结构标准，因为引入了较大的风险，“可重用性” 和 “软件高效性” 不易
					协调，需要精干的、有经验的分析和开发人员

					客户满意度低，并且由于过分依赖于构件，所以构件库的质量影响着产品的质量






		8.快速应用开发模型（RAD）：
				是一种 “增量型” 的软件开发过程模型，强调极短的开发周期
				RAD模型是 “瀑布模型” 的一个 “高速” 变种，通过大量使用 “可复用构件”，采用基于构件的
				建造方法赢得快速开发，若需求理解得好且约束了项目的范围，随后是数据建模、过程建模、应用生成、测试及反复

				第1组：业务建模——数据建模——过程建模——应用生成——测试及移交
				第2组：业务建模——数据建模——过程建模——应用生成——测试及移交
				...





		9.敏捷方法：
				敏捷开发是从20世纪90年代逐渐引起广泛关注的一新型软件开发方法，以应对快速变化的需求

				敏捷开发更强调 “程序员团队” 与 “业务专家” 之间的紧密协作、面对面沟通(在同一地点办
				公)、频繁交付新的软件版本、紧凑而自我组织型的团队（小型团队）、能够很好地适应需求变
				化的代码编写和团队组织方法（积极的、欢迎接受提出的调整），也更注重人的作用

				常见的敏捷开发方法：
								(1)极限编程（XP）
								(2)自适应软件开发
								(3)水晶方法
								(4)特性驱动开发
								(5)中国非常流行的：Scrum


				从开发者的角度，主要的关注点：

					1.短平快会议（Stand Up 站立式会议）
					2.小版本发布（Frequent Release）
								频繁发布版本，当你这个系统较Sass系统有改进了，就发布一个版本

					3.较少的文档（Minimal Documentation）
								只要一些重要的文档

					4.合作为重（Collaborative Focus）
								强调团队合作

					5.客户直接参与（Customer Engagement）
					6.自动化测试（Automated Testing）

					7.适应性计划调整（Adaptive Planning）
								拥抱变化，用户的需求发生变化了，我们要及时调整计划

					8.结对编程（Pair Programming）
								两个人同时负责一个模块、编写一个代码



				从管理者的角度，主要的关注点：

					1.测试驱动开发（Test-Driven Development）

					2.持续集成（Continuous Integration）
								频繁发布新版本

					3.重构（Refactoring）
								调整 “代码结构” 以改善软件质量、性能



				敏捷方法适用于 “中小型团队”，并且客户的需求模糊或需求多变

				这些方法所提出来的一些所谓的 “最佳实践” 并非对每个项目都是最佳的，需要项目团队根据
				实际情况来决定，而且，敏捷方法的有些原则在应用中不一定能得到贯彻和执行







		10.统一过程（UP/RUP）：
				是一个 “通用过程框架”，可以用于种类广泛的软件系统、不同的应用领域、不同的组织类型、
				不同的性能水平和不同的项目规模

				UP是基于构件的：软件系统建模时，UP使用的是 “UML”
							   与其他软件过程相比，具有三个显著特点：
																(1)用例驱动
																(2)以体系结构为中心
																(3)迭代和增量

				UP中的软件过程在时间上被分解为四个顺序的阶段：

					这四个阶段每个阶段可能都要经历如 “瀑布模型” 中的每个阶段，只是这每个阶段在这四
					个阶段中的侧重点、比例不同

						1.初始阶段：如业务建模、需求分析的比例大，而实施、测试等的占比就比较小
						2.细化阶段：如业务建模、需求分、设计、实施、测试的占比都大
						3.构建阶段
						4.交付阶段：如业务建模、需求分析的占比就小了，部署、配置管理占比就大了

					（即：这四个阶段各个阶段都包括传统的各个过程，只是各个阶段的侧重点不同）

				每个阶段都要安排一次 “技术评审”，以确定这个阶段的目标是否已经达到