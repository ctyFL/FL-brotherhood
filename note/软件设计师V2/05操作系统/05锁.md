锁：



	死锁：
		指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都
		将无法再向前推进


		(1)产生死锁的原因：

				1.竞争资源：
					当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要
					时，会引起诸进程对资源的竞争而产生死锁

						可把系统的中的资源分为两类：
						a.可剥夺性资源：资源分配给进程后可以被高优先级的进程剥夺，如CPU、主存

						b.不可剥夺性资源：分配给进程后只能在进程用完后才释放的资源，如：磁带、打印
						  机等

				2.进程间推进顺序非法：
					进程在运行过程中，请求和释放的顺序不当，也同样会导致产生死锁



		(2)产生死锁的必要条件：

				1.互斥条件：
						进程访问的临界资源，即在一段时间内某资源只由一个进程占用，如果此时还有其他
						进程请求该资源，则请求者只能等待，直至占有该资源的进程用完释放

				2.请求和保持条件：
						一进程在请求新的资源的同时，保持对已分配资源的占有

				3.不剥夺条件：
						指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放

				4.环路等待条件：
						指发生死锁时，必然存在一个进程--资源的环形链
						即进程集合{P0，P1，P2...Pn}中的P0正在等待一个P1占用的资源，P1正在等待一
						个P2占用的资源，...Pn正在等待一个已被P0占用的资源



		(3)处理死锁的基本方法：

				在系统中已经出现死锁后，则应及时检测到死锁的发生，并采取适当措施来接触死锁

				目前处理死锁的方法可归纳为四种：

						(1)预防死锁：
								是一种比较简单和直观的事先预防的方法，该方法是通过设置某些限制条件
								去破坏产生死锁的四个必要条件的一个或几个，来预防发生死锁

								摒弃 “请求和保持” 条件
								摒弃 “不剥夺” 条件
								摒弃 “环路等待” 条件

						(2)避免死锁：
								该方法同样是属于事先预防的策略，这种方法不是预先加上各种限制条件以
								防产生死锁的可能性，而是用某种方法去 “防止系统进入不安全状态”，使
								死锁不致于最终发生

								银行家算法避免死锁 
								
						(3)检测死锁：
								这种方法并不须事先采取然和限制性措施，也不必检测系统是否已经进入不
								安全区

								此方法允许系统在运行过程中发生死锁，但可以通过系统所设置的检测机构
								及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源，然后采
								取适当的措施，从系统中将已发生的死锁清除掉

						(4)解除死锁：
								是与死锁检测相配套的一种措施，当检测到系统中已发生死锁时，须将进程
								从死锁状态中解脱出来

								常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源
								分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行

								死锁的检测与解除措施，有可能使系统获得较好的资源利用率和吞吐量，但
								在实现上难度也最大