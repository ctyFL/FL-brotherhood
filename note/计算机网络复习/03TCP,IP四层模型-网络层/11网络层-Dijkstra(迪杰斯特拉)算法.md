网络层-Dijkstra（迪杰斯特拉）算法:
————OSPF协议中使用了这个算法

		Dijkstra算法是著名的图算法
		Dijkstra使用 “广度优先搜索” 解决有权图从一个节点到其他节点的最短路径问题
		以起始点为中心，向外层层扩展


		最短路径问题：
		（见图：迪杰斯特拉算法-最短路径问题.jpg）

		如图中这个网络，有A、B、C、D、E、F六个节点，并且有若干条边，并且每条边都有相应的距离
		每条边：AB=6、AC=9、AD=8、AF=7、BC=5、CD=3、CE=2、DE=1、EF=3

		求A到E的最短路径？
		那么有以下几种路径：
			A——>B——>C——>E：6 + 5 + 2 = 13
			A——>C——>E：9 + 2 = 11
			A——>D——>C——>E：8 + 3 + 2 = 13
			A——>D——>E：8 + 1 = 9
			A——>F——>E：7 + 3 = 10
		所以得出A到E的最短路径是 “A——>D——>E” 等于9






	求节点A到各个节点的最短路径
	Dijkstra（迪杰斯特拉）算法的过程：

			第一步：初始化两个集合(S,U)（S的元素只有节点A，因为是求节点A到各个节点的最短路径，U是其他各个节点的集合，即除了节点A的其他节点的集合）

			第二步：判断集合U是否为空，若U不为空，计算节点A到集合U里各个节点之间的距离，并按距离大小进行排序，并取出距离节点A最近的一个节点D（假设此时节点A到节点D的距离最近）
				1.取出节点D之后，纳入到S集合
				2.计算节点A通过节点D到达集合U里的其他剩余节点的距离
				  如果距离比原先（原先没有通过节点D）节点A到达集合U里的其他各个节点的距离小，则更新，否则不更新

			第三步：重复第二个步（继续对集合U排序，取出距离最小的节点纳入集合S...），直到集合U为空，算法结束





	例：
		如图：
		求节点A分别到B、C、D、E、F的最短路径？
		A->(B、C、D、E、F)

		1.首先先初始化一个A到各个节点的最短路径，此时只知道A到A距离=0，到B、C、D、E、F都还不知道
		  得出以下表a:
			节点   A
			 A    0
			 B    未知
			 C    未知
			 D    未知
			 E    未知
			 F    未知

		2.初始化集合S，纳入节点A，初始化集合U，纳入除节点A外其他节点
			S=[A]
			U=[B,C,D,E,F]

		3.计算集合S里的节点A到集合U里的各个节点之间的距离
			A->B=6
			A->C=9
			A->D=8
			A->E=未知（因为A不能直接到达E）
			A->F=7

			并更新表a：
			节点   A
			 A    0
			 B    6
			 C    9
			 D    8
			 E    未知
			 F    7

		4.通过计算后，可发现节点A到集合U里的节点B的距离最小为6：A->B=6
		  所以将节点B纳入集合S中，此时：
			S=[A,B]
			U=[C,D,E,F]

		5.然后计算节点A通过节点B到达集合U里其他剩余节点之间的距离
		  由图中()得知，节点B可以直接到达的节点只有C
			A->B->C=6+5=11
		  比较原先节点A（没有通过节点B）到达节点C的距离，发现没有更小：A->C=9<11，所以不更新

		6.判断集合U不为空，对集合U里的剩余节点排序，取出节点A到集合里的节点距离最小的节点，纳入集合S
		  发现此时最小为A->F=7，将F纳入集合S中，此时：
			S=[A,B,F]
			U=[C,D,E]

		7.然后计算节点A通过节点F到达集合U里其他剩余节点之间的距离
		  由图中()得知，节点F可以直接到达的节点只有E
			A->F->E=7+3=10
		  比较原先节点A（没有通过节点F）到达节点E的距离，发现原先是未知，所以要更新
		  更新表a：
			节点   A
			 A    0
			 B    6
			 C    9
			 D    8
			 E    10 (由原先“未知”更新为“10”)
			 F    7

		8.判断集合U不为空，对集合U里的剩余节点排序，取出节点A到集合里的节点距离最小的节点，纳入集合S
		  此时还剩C、D、E，而A->E更新为了10
		  发现此时最小为A->D=8，将F纳入集合S中，此时：
			S=[A,B,F,D]
			U=[C,E]

		9.然后计算节点A通过节点D到达集合U里其他剩余节点之间的距离
		  由图中()得知，节点D可以直接到达的节点有C、E
			A->D->C=8+3=11
			A->D->E=8+1=9
		  比较原先节点A（没有通过节点D）到达节点C的距离，发现没有更小：A->C=9<11，所以不更新
		  比较原先节点A（通过节点F到达节点E）到达节点E的距离，发现更小了：A->F->E=10>9，所以更新
		  更新表a：
			节点   A
			 A    0
			 B    6
			 C    9
			 D    8
			 E    9 (由原先“10”更新为“9”)
			 F    7

		10.判断集合U不为空，对集合U里的剩余节点排序，取出节点A到集合里的节点距离最小的节点，纳入集合S，此时还剩C、E，而A->E更新为了9
		  发现此时最小为A->C=9，A->E=9，所以随意取出一个纳入集合S中，取出E，此时：
			S=[A,B,F,D,E]
			U=[C]

		11.然后计算节点A通过节点E到达集合U里其他剩余节点之间的距离
		  由图中()得知，节点E可以直接到达的节点有C、D、F，但只需计算到节点C，因为A不能直接通过E到达D、F，而是通过D、F到达E
			A->E->C=8+1+2=11
		  比较原先节点A（没有通过节点E）到达节点C的距离，发现没有更小：A->C=9<11，所以不更新

		12.判断集合U不为空，对集合U里的剩余节点排序，取出节点A到集合里的节点距离最小的节点，纳入集合S，此时只剩C了，把C纳入到集合S中，此时：
			S=[A,B,F,D,E,C]
			U=[]

		13.然后计算节点A通过节点C到达集合U里其他剩余节点之间的距离
		  由图中()得知，节点C可以直接到达的节点有B、D、E
			A->C->B=9+5=14
			A->C->D=9+3=12
			A->C->E=9+2=11
		  比较发现都不需要更新

		14.判断集合U为空，算法结束

		15.最后结果为（节点A到各个节点之间的最短路径）：

			节点   A
			 A    0
			 B    6
			 C    9
			 D    8
			 E    9
			 F    7