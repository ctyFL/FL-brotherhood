网络层-内部网关路由协议-RIP：

			距离矢量（DV）算法：（是关于图的算法）
				1.每一个节点使用两个向量：Di、Si
				2.“Di” 描述的是当前节点到别的节点的 “距离”
				3.“Si” 描述的是当前节点到别的节点的 “下一节点” 是什么
				4.每一个节点与相邻的节点交换向量 “Di” 和 “Si” 的信息
				5.每一个节点根据交换的信息更新自己的节点信息


				di1：表示从 “节点i” 到 “节点1” 的距离
				si1：表示从 “节点i” 到 “节点1” 的下一个节点
				
				这个算法的目的就是求出这个D距离的最小值
				dij = min(dix + dxj)






			见图（以图的形式描述网络拓扑.jpg）
			图上有A、B、C、D、E、F这6个节点，以及若干条边

			就有Di，节点i分别到A、B、C、D、E、F这6个节点的距离：dia、dib、dic、did、die、dif
			Di={dia，dib，dic，did，die，dif}

			就有Si，节点i分别到A、B、C、D、E、F这6个节点的下一个节点是什么：sia、sib、sic、sid、sie、sif
			Si={sia，sib，sic，sid，sie，sif}


			以节点A来演示DV算法是怎样运行的（求Da，Sa这两个向量）：
			整个过程主要就是节点A与其他各个节点进行交换距离矢量信息
			（见图：距离矢量算法.jpg）


			1.假设A的初始化的距离矢量信息（Da）如下：

			  目标节点   节点A到目标节点的距离（这里不是直线距离，可能是A通过其他节点再到目标节点）
				  A               0
				  B               11
				  C               12
				  D               10
				  E               21
				  F               17


			2.现在A收到了其他节点的距离矢量信息如下（能和A直接通信的节点）：

			 目标节点   B到目标节点距离   C到目标节点距离   D到目标节点距离   F到目标节点距离
				A            9               12               9                9
				B            0                9               8               15
				C           11                0               6               11
				D            7                8               0               10
				E           17               11              11               13
				F           11               10              10                0


			3.同时A收到了A到各个节点的直线距离（指到这个节点不需经过其他节点，可以直接通信）：
				通过直接通信得知：AB=6，AC=9，AD=8，AF=7（这里是直线距离，详见：距离矢量算法.jpg）因为A能和BCDF直接通信，所以知道直接距离（指到这个节点不需经过其他节点）


			4.将各个节点的距离矢量信息融合成一张表：

				节点   A    B    C    D    F
				 A     0    9   12    9    9
				 B    11    0    9    8   15
				 C    12   11    0    6   11
				 D    10    7    8    0   10
				 E    21   17   11   11   13
				 F    17   11   10   10    0

				疑问：为什么节点A到节点B的距离是11，但节点B到节点A的距离是9呢？
					因为这里不是直线距离，而且距离矢量是动态的
					如：节点A到节点B的距离可能是A到C再到B得到的：A->C->B
					    节点B到节点A的距离可能是B到C到D再到A所得到的：B->C->D->A
			   （详见：距离矢量算法.jpg）


			5.计算节点A通过B节点到各节点的距离（即A与B交换距离矢量信息）：

				之前得知了A与BCDF直接通信的直线距离，A->B=6（直接通信）
				结合B节点的距离矢量信息得出:
				A->B=6
				A->B->C=6+11=17
				A->B->D=6+7=13
				A->B->E=6+17=23
				A->B->F=6+11=17

				将这些结构与A原来的距离矢量信息比较，若距离更短，则把更短的更新上去
				这里将A——>B的节点距离从原来的11更新为6
				就变成了：

			  	节点     A
				  A     0
				  B     6（原11更改为6）
				  C     12
				  D     10
				  E     21
				  F     17

				更改后，可以得知节点A到节点B的下一个节点就是B，所以求出节点A的Sb=B（节点A到节点B的下一节点是B）
				同时，看出A->B->F=17和原距离矢量信息中节点A到节点F的距离相等，因此也可以求出节点A的sf=B（节点A到节点F的下一节点是B：A->B->F）


			6.计算节点A通过C节点到各节点的距离（即A与C交换距离矢量信息）：

				之前得知了A与BCDF直接通信的直线距离，A->C=9（直接通信）
				结合C节点的距离矢量信息得出:
				A->C=9
				A->C->B=9+9=18
				A->C->D=9+8=17
				A->C->E=9+11=20
				A->C->F=9+10=19

				将这些结构与A原来的距离矢量信息比较，若距离更短，则把更短的更新上去
				这里将A——>C的节点距离从原来的12更新为9
				这里将A——>E的节点距离从原来的21更新为20
				就变成了：

			  	节点     A
				  A     0
				  B     6
				  C     9（原12更改为9）
				  D     10
				  E     20（原21更改为20）
				  F     17

				更改后，可以得知节点A到节点C的下一个节点就是C，所以求出节点A的Sc=C（节点A到节点C的下一节点是C）
				节点A到节点E的下一个节点是C，所以节点A的Se=C


			7.以此类推，通过A与D、F交换距离矢量信息来计算节点A到各个节点的距离（Da）
				以及到各个节点的下一跳（Sa下一节点是什么）

			（详细见：距离矢量算法.jpg）







	RIP协议的过程：
		（Routing Information Protocol）

			RIP协议是使用距离矢量算法(DV)的一种路由协议

			1.RIP协议把网络的跳数(hop)作为DV算法的距离（如以上A->B的距离=6，就代表跳了6次）
			2.RIP协议认为跳数>15的跳数则为不可达路由
			3.RIP协议每隔30s交换一次路由信息

			工作过程：
				1.首先路由器会初始化路由信息（Di和Si向量）
				2.路由器会与相邻的路由器进行信息交换，对相邻的路由器X发过来的信息，对信息的内容进行修改：
				 （下一跳地址设置为X（代表路由器X），所有距离加1：通过X可以到达X所发过来的信息的每一个节点，只需要把距离加1就可以了）
					第一步：首先检索本地的路由，将信息中新的路由插入到路由表里面（因为X所发过来的信息里面，可能有一些目的地是本机没有的）
					第二步：检索本地路由，对于下一跳为X的，更新为修改后的信息（即通过路由器X到达其他节点，更新后，意味原来旧的信息作废了）
					第三步：检索本地路由，对比相同目的的距离（即把通过路由器X到达其他节点的距离与本地原来的到达其他节点对比————DV算法交换向量），如果新信息的距离更小，则把距离小的路由信息更新到本地路由表
				3.若3分钟没有收到相邻的路由信息，则把路由设置为不可达（16跳）


			例子：
				1.假设一个路由器R初始化的路由信息如下：

					节点  Di  si
					 D    2   A

				（表示这里路由器R到达节点D的距离是2，下一跳节点是A）


				2.收到相邻路由器X发过来的信息：

					节点  Di  Si
					 A    4   C
					 B    2   C

				（表示路由器X到达节点A的距离是4，下一跳节点是C，到节点B的距离是2，下一跳节点是C）

				路由器R收到路由器X发过来的信息，会对本机的信息内容进行修改，下一跳地址设置为X，所有距离加1：

					节点  Di  Si
					 A    5   X
					 B    3   X

				（表示路由器R到节点A的距离为路由器X到节点A的距离加1=5，路由器R到节点B的距离=2+1=3，下一跳节点都为路由器X）

				第一步：路由器R检索本地路由，将信息中新的路由插入到路由表里面（因为X所发过来的信息里面，可能有一些目的地是本机没有的）这里为节点A、B，插入后如下：

					节点  Di  Si
					 D    2   A
					 A    5   X
					 B    3   X

				第二步：检索本地路由，对于下一跳为X的，更新为修改后的信息（即通过路由器X到达其他节点，更新后，意味原来旧的信息作废了）

					现假设路由器R的初始化路由信息如下：

					路由器R
					节点  Di  Si
					 A    2   X
					 B    5   X
					（发现到节点A、B的下一跳为路由器X）


					收到相邻路由器X发过来的信息

					路由器X
					节点  Di  Si
					 A    4   C
					 B    2   C
					（收到后，对信息内容进行修改，下一跳设置为X，所有距离+1，发现到节点A、B的距离更新了，变成了5、3，所有更新为修改后的信息）

					节点  Di  Si
					 A    5   X
					 B    3   X

				第三步：检索本地路由，对比相同目的的距离（即把通过路由器X到达其他节点的距离与本地原来的到达其他节点对比————DV算法交换向量），如果新信息的距离更小，则把距离小的路由信息更新到本地路由表

					现假设路由器R的初始化路由信息如下：

					节点  Di  Si
					 A    3   D
					 B    5   F

					(路由器R到节点A的距离为3，下一跳节点为D，到节点B的距离为5，下一跳节点为F)

					收到路由器X发过来的路由信息：

					节点  Di  Si
					 A    4   C
					 B    2   C

					收到信息后首先下一跳地址设置为X（代表路由器X），所有距离加1，得到：

					节点  Di  Si
					 A    5   X
					 B    3   X

					发现于路由器R的初始化信息中，存在相同目的地A、B，所以进行交换向量（DV算法交换向量）：
					路由器R初始化路由信息中，R——>D——>A=3 小于 R——>X——>C——>A=5，所以不需要交换
					R——>F——B=5 大于 R——>X——>C——>B=3，则更新，设为：Db=3，Sb=X

					更新后为：
					节点  Di  Si
					 A    3   D   —————— 对比后发现原先的距离更小，不需要更新
					 B    3   X   —————— 对比后发现通过路由器X距离更小，距离由原先的5改为3，下一跳由原先的F改为路由器X




		 RIP协议的缺点：实现简单，开销很小
		 RIP协议的缺点：
				限制了网络的规模（只要跳数>15就认为不可达）
				故障信息传递慢，更新收敛时间长

				例：节点A、B、C线性连接：A<------->B<------->C

					C到A的距离为2，C通过B到A
					B到A的距离为1，B直接到达到A

					当某个时候，A宕掉了，B发现A不可达了，于是B就去询问C，发现通过C可以到达A
					于是B把下一跳设置为C，距离就是C到A的距离加1等于3

					然后，C发现A不可达了，于是就去询问B，发现通过B可以到达A
					于是C把下一跳设置为B，距离就是B到C到A的距离加1等于4

					...这样循环下去，一直到距离大于15为16跳时，才发现A不可达了

					因为网络故障经常发生，若每次故障都需要这么多次后才能收敛，会导致整个网络不可控