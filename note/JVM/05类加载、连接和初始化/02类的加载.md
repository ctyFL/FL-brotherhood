类的加载：

		1.通过类的全名来获取改类的二进制字节流
			（带上包结构加类名————通后包名找到唯一的这个类，将它读进来）

		2.把二进制字节流转化为方法区的运行时数据结构
			（后面会详细讲，这里只需要了解到，我们把类文件装载进来后，最终是存储到方法区的运行时数据结构）
			（也就是说加载阶段结束后，虚拟机外部的这个二进制字节流就按照虚拟机所设定的模式存储在方法区当中了）

		3.在堆上创建了一个 “java.lang.Class” 对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口
			（当我们去new一些实例类过后，我们每个实例都能调用.getClass()方法，这个调的.getClass()方法其实就是这个 “java.lang.Class” 对象，拿到这个对象后，我们就可以通过反射，去拿到这个对象的所有的可访问的基本信息————方法、属性等）

		
		加载类的常见的方式：
			从本地文件中加载（classpath下）、从jar包、war包等归档文件中加载

		加载类的动态的方式：
			将java源文件动态编译成class如ASM直接修改、输出class文件

		其他方式：
			网络下载、从专有数据库中加载等



类加载器ClassLoader：（由它来完成类加载的过程）

		JVM虚拟机里自带了一些加载器，如下几种：
			
			1.启动类加载器（BootstrapClassLoader）

			2.JDK9之后为：平台类加载器（PlatformClassLoader）：
			  JD8中为：没有平台类加载器，而是“扩展类加载器”（ExtensionClassLoader）
			  ExtensionClassLoader主要是去加载jre环境下的lib下的ext下的jar包，也就是我们想要扩展这样的功能的时候，将jar包放在这个目录下，实际上这样不安全，所有jdk9后将它替换成平台类加载器，另外，我们想要扩展这样的功能的话，jdk9中有模块化的开发，模块化的扩展能力更好

			3.应用程序类加载器（AppClassLoader）：我们做的应用程序一般是用应用程序类加载器加载的


		用户自定义的加载器：
			是 “java.lang.ClassLoader” 的子类，用户可以定制类的加载方式
			注意：自定义加载器的加载顺序是在所有系统类加载器（虚拟机提供的加载器）的最后

		
		类加载器之间的关系（层级关系）：
			（————>表示继承至）

			自定义加载器————>应用程序类加载器————>平台类加载器（JDK8则为扩展类加载器）————>启动来加载器