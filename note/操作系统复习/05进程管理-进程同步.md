进程管理-进程同步：

		生产者-消费者问题：
				有一群 “生产者进程” 在生产产品，并将这些产品提供给 “消费者进程” 进行消费
				“生产者进程” 和 “消费者进程” 可以 “并发” 执行
				两者之间设置了一个容量为n个缓冲区的 “缓冲池”

				“生产者进程” 将生产好的产品放入一个 “缓存区” 中
				“消费者进程” 可以从 “缓冲区” 中取走产品进行消费

				生产者进程                         消费者进程
					a  ---------->|       |----------> e
					b  ---------->| 缓冲池 |----------> d
					c  ---------->|       |----------> f

				生产者生产好一个产品，往缓冲池+1
				消费者往缓冲池取出一个产品消费，缓冲池-1



				以上在生活中宏观上没有问题，然而在计算机微观上会出现问题：

					这个 “缓冲池” 是位于 “高速缓存(Cache)” 或 “主存” 上的

					生产者/消费者操作缓冲池的三个步骤：

						(register:CPU寄存器，生产者或消费者、count:缓冲池，仓库)

						1.先把缓冲池里的数据取出来，放入CPU的寄存器里面
						register=count				

						2.CPU寄存器里将数据加一或减一（即生产者生产或消费者消费）
						register=register+1 / register=register-1

						3.把数据放回缓冲池里面
						count=register

					以上三个步骤的程序，单从生产者程序或从消费者程序看没有问题
					但当两者并发进行时就可能出错

					两者并发、交替运行：
						count = 10

						1.生产者从缓冲池中取出数据，并加一
							r1 = count
							r1 = r1 + 1
							r1 = 10 + 1 = 11

						2.消费者从缓冲池中取出数据，并减一
							r2 = count
							r2 = r2 - 1
							r2 = 10 - 1 = 9

						3.消费者将数据放回缓冲池
							count = r2
							count = 9

						4.生产者将数据放回缓冲池
							count = r1
							count = 11

						然而正确count应该等于10





		出现这个问题的原因：
						彼此之间没有通信，如生产者加一产品后，没有通知消费者
						——————因此需要 “进程间的同步”					





		进程同步：
				对竞争资源在多进程间进行使用次序的协调
				使得并发执行的多个进程之间可以有效使用资源和相互合作


				临界资源：指虽作为共享资源，却又无法同时被多个进程共同访问的共享资源，当有
						 进程在使用临界资源时，其他进程必须依据操作系统的同步机制，
						 “等待” 占用进程 “释放” 该共享资源才可 “重新竞争” 使用共享资源



				为了约束使用 “临界资源”
				有以下原则

				进程间同步的原则：

						1.空闲让进：资源无占用，允许使用
									（临界资源没有被占用，操作系统允许某个进程使用临界资源）

						2.忙则等待：资源有占用，请求进程等待
									（临界资源被占用了，其他进程等待直到资源被释放）

						3.有限等待：保证有限等待时间能够使用资源
									（在忙则等待上，保证别的进程等待有限时间，而不会僵死）

						4.让权等待：等待时，进程需要让出CPU
								（在等待的这些进程需要让出CPU资源即进入阻塞状态，保证CPU利用率）




				进程同步的方法有：
						1.消息队列
						2.共享存储
						3.信号量








		线程同步：
				一个进程里可能有多个线程，多个线程共享进程资源，也会并发的去使用进程里共享的资源
					——————所以进程内线程也需要同步

				线程同步的方法：
							1.互斥量
							2.读写锁
							3.自旋锁
							4.条件变量