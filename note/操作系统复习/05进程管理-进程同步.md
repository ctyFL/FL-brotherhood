进程管理-进程同步：

		生产者-消费者问题：
				有一群 “生产者进程” 在生产产品，并将这些产品提供给 “消费者进程” 进行消费
				“生产者进程” 和 “消费者进程” 可以 “并发” 执行
				两者之间设置了一个容量为n个缓冲区的 “缓冲池”

				“生产者进程” 将生产好的产品放入一个 “缓存区” 中
				“消费者进程” 可以从 “缓冲区” 中取走产品进行消费

				生产者进程                         消费者进程
					a  ---------->|       |----------> e
					b  ---------->| 缓冲池 |----------> d
					c  ---------->|       |----------> f

				生产者生产好一个产品，往缓冲池+1
				消费者往缓冲池取出一个产品消费，缓冲池-1



				以上在生活中宏观上没有问题，然而在计算机微观上会出现问题：

					这个 “缓冲池” 是位于 “高速缓存(Cache)” 或 “主存” 上的

					生产者/消费者操作缓冲池的三个步骤：

						(register:CPU寄存器，生产者或消费者、count:缓冲池，仓库)

						1.先把缓冲池里的数据取出来，放入CPU的寄存器里面
						register=count				

						2.CPU寄存器里将数据加一或减一（即生产者生产或消费者消费）
						register=register+1 / register=register-1

						3.把数据放回缓冲池里面
						count=register

					以上三个步骤的程序，单从生产者程序或从消费者程序看没有问题
					但当两者并发进行时就可能出错

					两者并发、交替运行：
						count = 10

						1.生产者从缓冲池中取出数据，并加一
							r1 = count
							r1 = r1 + 1
							r1 = 10 + 1 = 11

						2.消费者从缓冲池中取出数据，并减一
							r2 = count
							r2 = r2 - 1
							r2 = 10 - 1 = 9

						3.消费者将数据放回缓冲池
							count = r2
							count = 9

						4.生产者将数据放回缓冲池
							count = r1
							count = 11

						然而正确count应该等于10





		出现这个问题的原因：
						彼此之间没有通信，如生产者加一产品后，没有通知消费者
						——————因此需要 “进程间的同步”					





		1.进程同步：
				对竞争资源在多进程间进行使用次序的协调
				使得并发执行的多个进程之间可以有效使用资源和相互合作


				(1)临界资源：指虽作为共享资源，却又无法同时被多个进程共同访问的共享资源，当有
						 进程在使用临界资源时，其他进程必须依据操作系统的同步机制，
						 “等待” 占用进程 “释放” 该共享资源才可 “重新竞争” 使用共享资源



				为了约束使用 “临界资源”
				有以下原则

				(2)进程间同步的原则：

						1.空闲让进：资源无占用，允许使用
									（临界资源没有被占用，操作系统允许某个进程使用临界资源）

						2.忙则等待：资源有占用，请求进程等待
									（临界资源被占用了，其他进程等待直到资源被释放）

						3.有限等待：保证有限等待时间能够使用资源
									（在忙则等待上，保证别的进程等待有限时间，而不会僵死）

						4.让权等待：等待时，进程需要让出CPU
								（在等待的这些进程需要让出CPU资源即进入阻塞状态，保证CPU利用率）




				(3)进程同步的方法有：
						1.消息队列
						2.共享内存
						3.信号量


						共享内存：
							a.一个操作系统中有多个进程，进程共享计算机资源（包括内存、磁盘等）
							
							b.每一个进程都有自己的 “进程空间（内存空间）”，“进程空间（内存空间）” 
							  通过 “页表” 段页式存储管理与实际的物理内存建立起映射，进程之间，他
							  们的进程空间（内存空间）是互不干扰，相互独立的

							c.在某种程度上，多进程是共同使用物理内存的

							d.进程是默认不能访问自己的 “进程空间（内存空间）” 之外的内存空间（其
							  他进程的内存空间）

							通过共享内存：
								(1)多个进程通过页表映射到同一片物理内存里（共享内存），这片共享内
								   存可以被进程1读、写，也可以被进程2读、写

									即：共享内存允许不相关的进程访问同一片物理内存，把这片相同的
										物理内存分别映射到不同进程的页表中去

								(2)共享内存是两个进程之间共享和传递数据最快的方式
									（后台很多高性能的服务都是通过共享内存来通信的）

								(3)共享内存未提供同步机制，需要借助其他机制管理多个进程对同一块内
								   存的访问


							实现的步骤：
								1.向操作系统申请共享内存
								2.连接到进程空间
								3.使用共享内存
								4.脱离进程空间、删除共享内存


							C++例子：
								有一个客户端，一个服务端，他们之间通过共享内存来进行通信

								客户端<——————{共享内存}——————>服务端


								1.共享内存common：

								//共享内存的数据结构
								Struct ShmEntry{
									//是否可以读取共享内存，用于进程间同步
									bool can_read；

									//共享内存信息，2048表示字符最大长度
									char msg[2048]；
								}



								2.服务端server：

								int main(){

									//定义共享内存的结构体
									struct ShmEntry entry；

									//1.申请共享内存
									int shmid 
										= shmget((key_t))1111，sizeof(struct ShmEntry)，
										  0666|IPC_CREAT)；

									if(shmid == -1){
										std::cout << "Create share memory error" << std:endl；
									}

									//2.连接到当前进程空间/使用共享内存
									entry = (ShmEntry*)shmat(shmid，0，0)；
									entry->can_read = 0；
									while(true){
										if(entry->can_read == 1){
											std::cout << "Recevied message：" << entry->msg << std::endl；
											entry->can_read = 0；
										}else{
											std::cout << "Entry can not read，Sleep 1s" << std::endl；
											sleep(1)；
										}
									}

									//3.脱离进程空间
									shmdt(entry)；

									//4.删除共享内存
									shmctl(shmid，IPC_RMID，0)；

									return 0；
								}


							3.客户端client(客服端就使用共享内存的部分和服务端不一样，其他都一样）

							int main(){

									//定义共享内存的结构体
									struct ShmEntry entry；

									//1.申请共享内存
									int shmid 
										= shmget((key_t))1111，sizeof(struct ShmEntry)，
										  0666|IPC_CREAT)；

									if(shmid == -1){
										std::cout << "Create share memory error" << std:endl；
									}

									//2.连接到当前进程空间/使用共享内存
									entry = (ShmEntry*)shmat(shmid，0，0)；
									entry->can_read = 0；
									while(true){
										if(entry->can_read == 0){
											std::cout << "Input message："；
											fgets(buffer，TEXT_LEN，stdin)；
											std::cout << "Send message: " << entry->msg << std::endl；
											entry->can_read = 0；
										}
									}

									//3.脱离进程空间
									shmdt(entry)；

									//4.删除共享内存
									shmctl(shmid，IPC_RMID，0)；

									return 0；
								}






				(4)进程同步之Unix域套接字：
						套接字（soket）原是网络通信中使用的术语
						Unix系统提供的域套接字提供了网络套接字类似的功能

						我们在部署服务、使用Nginx、uWSGI等都会使用到Unix域套接字

						1.服务端server使用Unix域套接字过程：
							创建套接字————>绑定(bind)套接字————>监听(listen)套接字————>接受&处理信息

						2.客户端client使用Unix域套接字过程：
							创建套接字————>连接套接字————>发生信息








		2.线程同步：
				一个进程里可能有多个线程，多个线程共享进程资源，也会并发的去使用进程里共享的资源
					——————所以进程内线程也需要同步

				线程同步的方法：
							1.互斥量
							2.读写锁
							3.自旋锁
							4.条件变量