作业管理-死锁：

		死锁：
			指两个或两个以上的进程在执行过程中，由于 “竞争资源” 或由于 “彼此通信” 而造成的一种阻塞
			的现象，若无外力作用，它们都无法推进下去
				————此时称系统处于 “死锁状态” 或 “系统产生了死锁”
					这些永远在互相等待的进程称为 “死锁进程”




		产生死锁的原因：

				1.竞争资源：
						共享资源数量不满足各个进程需求，各个进程之间发生资源竞争
							如：
								“进程1” 需要使用 “传真机资源”，并且获取到了
								“进程2” 需要使用 “打印机资源”，并且获取到了
								此时，“进程1” 还需要 “打印机资源”，于是等待 “进程2” 释放该资源
								“进程2” 还需要 “传真机资源”，于是等待 “进程1” 释放该资源
								然而都阻塞着，都不会释放自己已占用的资源
								————导致死锁

								若多一个打印机或多一个传真机都可以避免这种情况
								————所以本质还是资源不够的原因

				2.进程调度顺序不当：
						如：
							步骤A：“进程1” 调用 “传真机资源”
							步骤B：“进程2” 调用 “打印机资源” 
							步骤C：“进程2” 调用 “传真机资源”
							步骤D：“进程1” 调用 “打印机资源” 

						若进程的调度顺序为：A——>B——>C——>D
							则会引起竞争资源的问题导致死锁

						若将进程的调度顺序改为：A——>D——>B——>C
							则进程1就可以先获取到 “传真机资源” 和 “打印机资源”
							执行完工作然后释放这两个资源
							进程2就也可以获取到这两个资源继续工作



		产生死锁的四个必要条件：

				1.互斥条件：
						进程对资源的使用是 “排他性的使用”
						某资源只能被一个进程使用，其他进程需要使用时只能等待资源被释放

				2.请求保持条件：
						进程至少保持一个资源，又提出新的资源请求
						新资源被占用，请求被阻塞
						被阻塞的进程不释放自己保持的资源

				3.不可剥夺条件：
						进程获得的资源在未完成使用前不可被剥夺，该资源只能由进程自己释放
						

				4.环路等待条件：
						发生死锁的时候，必然发生 “进程-资源环形链”







		死锁的处理：

			预防死锁的方法：
				1.摒弃请求保持条件：
						规定进程运行之前，一次性申请所有需要的资源，从而进程在运行期间不会提出资源
						请求，不会出现等待的情况

				2.摒弃不可剥夺条件：
						当一个进程请求新的资源得不到满足时，必须释放占有的资源，进程运行时占有的资
						源可以被释放，意味着可以被剥夺

				3.摒弃环路等待条件：
						可用资源线性排序，申请必须按照需要递增申请，线性申请不再形成环路

				银行家算法：
						是一个可操作的著名的避免死锁的算法
						以银行借贷系统分配策略为基础的算法

						客户申请的贷款是有限的，每次申请需声明最大资金量
						银行家在能够满足贷款时，都应该给用户贷款
						客户在使用贷款时后，能够及时归还贷款

				例：
					如下表：
					P1~P4表示进程 A~D表示资源

					已分配资源表（表示各个进程当前拥有的资源的情况）

						A	B	C	D
					P1	0	0	1	4
					P2	1	4	3	2
					P3	1	3	5	4
					P4	1	0	0	0


					所需资源表（表示各个进程总共需要的资源数）

						A	B	C	D
					P1	0	6	5	6
					P2	1	9	4	2
					P3	1	3	5	6
					P4	1	7	5	0


					可分配资源表（表示当前系统剩余的、可以分配的资源）

						A	B	C	D
						1	5	2	0


					1.将 “所需资源表” 减去 “已分配资源表” 就可以得出各个进程还需要的资源数

					还需配资源表

						A	B	C	D
					P1	0	6	4	2
					P2	0	5	1	0
					P3	0	0	0	2
					P4	0	7	5	0

					2.然后将 “可分配资源表” 与 “还需配资源表的每一行” 对比，即对比各个进程
					  发现可分配资源里各个资源的资源数只可以完全满足P2的需求
					  所以将可分配的资源都先分配给P2，让P2可以执行下去
					  当P2执行完后，便归还所有资源，然后再继续分配给其他进程，继续执行下去 