Linux的存储管理：


		Buddy内存管理算法：
				是经典的内存管理算法，是Linux实际运行中的一种内存管理算法
				该算法基于计算机处理二进制的优势，具有极高的效率
				该算法主要是为了解决 “内存外碎片（页外碎片）” 的问题
				“努力让内存分配与相邻内存合并并能快速进行”


				页内碎片：
						回顾前面学的 “段页式存储管理” 中的 “内存碎片(页内碎片)”
						“页内碎片” 就是已经被分配出去（能明确指出属于哪个进程）的内存空间 “大于” 
						请求所需的内存空间，剩余的不能被利用的内存空间就是 “页内碎片”


				页外碎片：
						指的是还没有被分配出去（不属于任何进程），但是由于大小无法分配给申请内存空
						间的新进程的内存空闲块



				该算法内存分配的原则：
						1.分配内存时默认的每一块内存向上取整为2的幂大小
							例：
								一个进程申请的内存大小为70k，
								那么Buddy内存分配会向上取整为2的幂次方，为128K
								（2^6=64 2^7=128）

								一个进程申请的内存大小为129K，
								那么Buddy内存分配会向上取整为2的幂次方，为256K
								（2^7=128 2^7=256）

						2.伙伴系统：
							“伙伴” 指的是内存的 “伙伴”
							一片连续内存的 “伙伴” 是相邻的另一片大小一样的 “连续内存”
							（两个连续的内存互为 “伙伴”）



				分配算法过程：
						1.创建一系列空闲块链表，每一种都是2的幂次方
						  如：
							1KB：节点1<=>节点2<=>节点3<=>节点4<=>节点5
							2KB：节点1<=>节点2<=>节点3<=>节点4<=>节点5
							4KB：节点1<=>节点2<=>节点3<=>节点4<=>节点5
										...
							1MB：节点1<=>节点2<=>节点3<=>节点4<=>节点5

						例：
							假设存储空间有1M大小

							初始化的空闲块链表如下：
						   （1KB~512KB这些初始化时都是没有节点的只有1MB的有一个节点，大小为1MB）
								1KB null
								2KB null
								4KB null
								...
								1MB 节点1(1MB)
							

						2.此时要分配100K的内存大小
							100K先上取整2的幂次方 2^7=128K
							查询是否有128K空闲的空闲块？
							发现没有，查询是否有256K空闲的空闲块？
							发现没有，查询是否有512K空闲的空闲块？
							发现没有，查询是否有1M空闲的空闲块？
							发下有，则摘下1M空闲内存块，分配出去

							此时1M的空闲块链表上没有节点了
							1MB null

							摘下512K放到512K的空闲块链表中，其余的分配出去（检查剩下的256K是否满足了100K的最小需求）
							发现512K还没有满足最小的需求
							摘下256K放到256K的空闲块链表中，其余的分配出去（检查剩下的256K是否满足了100K的最小需求）
							发现256K还没有满足100K的最小需求
							摘下128K放到128K的空闲块链表中，其余的分配出去（检查剩下的128K是否满足了100K的最小需求）
							发现已经满足了，分配完毕
							


				回收刚才分配的内存：
					1.判断刚才分配的内存的伙伴是否在空闲块链表上
					（即刚刚分配出去的128K的内存块的 “伙伴(相邻的、另一个128K的内存块)” 是否在空闲块链表上）

					2.若在，移除伙伴，合并为256K的空闲内存
					3.再判断256K的伙伴是否在空闲块链表上
					4.若在，移除伙伴，合并为512K的空闲内存
					5.再判断512K的伙伴是否在空闲块链表上
					6.若在，移除伙伴，合并为1M的空闲内存
					7.再判断1M的伙伴是否再空闲块链表上
					8.发现没有，则将1M的空闲块内存插入到1M的空闲块链表上，回收完毕

					回收之后，又变回初始化的状态：
						1KB null
						2KB null
						4KB null
						...
						1MB 节点1(1MB)


				该算法是为了解决内存外碎片的问题
				实际上是将 “内存外碎片问题” 转移成了 “内存内碎片问题”
				如以上例子中，进程需要100K内存，但是给它分配了128K内存
				这多出来的28K就是 “内存内碎片”
				————即使这样，Buddy内存管理算法也大大提升了内存的利用率，因为内存外碎片会更大





		Linux交换空间：
				（交换空间作用与虚拟内存类似）

				交换空间(Swap)是磁盘的一个分区
				当Linux物理内存满时，会把一些内存交换至Swap空间，使得Linux有更多的内存去运行
				Swap空间的大小是初始化系统时配置的（装系统时）

				Linux中Shell，输入 “top” 命令，就可以查看到总共的Swap空间大小和已用的、可用的大小

			不推荐使用Swap交换空间，因为Swap是在磁盘上的，磁盘的速度慢，因此频繁使用Swap交换空间会导致Linux运行起来很慢


				交换空间的作用：
					1.冷启动内存依赖：
							对于一些大型的应用程序，在启动的时候需要大量的内存数据，有些数据只是在启动的时候用一下，后续很少会用到，因此使用 “交换空间”，可以把大量的不
							怎么需要使用的内存数据保存到Swap交换空间里面去，从而保留更多的 “物理
							内存” 提供给系统使用

					2.系统睡眠依赖：
							当Linux系统休眠的时候，就会把系统里面的所有内存数据，都保存在 “Swap空
							间” 里面，系统再次启动的时候，再把这些数据重新加载到内存里面，就可以加
							快系统启动速度

					3.大进程空间依赖：
							有些进程需要很大的内存空间，但是物理内存不够用，因此把进程需要使用的内
							存数据暂时保存到 “Swap空间” 里


			“Swap交换空间” 与 “虚拟内存” 的对比：

				相同：
					1.交换空间、虚拟内存都存在于磁盘
					2.交换空间、虚拟内存都是与主存发生置换

				不同：
					1.交换空间是 “操作系统的概念”
					  虚拟内存是 “进程概念”（我们平时说虚拟内存都是说某个进程的虚拟内存、而不是系统的虚拟内存）

					2.交换空间解决 “系统” 物理内存不足的问题
					  虚拟内存解决 “进程” 物理内存不足的问题
