存储管理-内存分配：

			早期计算机编程并不需要过多的存储管理
			随着计算机越来越复杂，存储管理成为必要
			为了确保：
					a.确保计算机有足够的内存处理数据
					b.确保程序可以从可用内存中获取一部分内存使用
					c.确保程序可以归还使用后的内存以供其他程序使用


			内存分配的方法：
				
				1.单一连续分配：（已过时）
					是最简单的内存分配方式
					只能在单用户、单进程的操作系统中使用

					方式：把内存分为 “系统区” 和 “用户区”

					系统区：系统区的内存都给操作系统使用
					用户区：用户区的内存都给用户区的程序使用


				2.固定分区分配：
					是支持 “多道程序” 的最简单的存储分配方式

					方式：将内存空间划分为若干个 “固定大小” 的区域
						每个分区都提供给 “一个程序” 使用，互不干扰


				3.动态分区分配：
					根据实际需要，动态分配内存空间
					（涉及相关数据结构、分配算法）

					相关数据结构：
						内存中有多干个分区，有的被使用了有的空闲，我们就需要一个数据结构去存储分区
						 “是否被使用” 的状态

						1.动态分区 “空闲表” ：
							a~g表示分区 标记 0表示没有被使用 1表示被使用了

							分区 a b c d e f g...
							标记 0 1 0 0 1 1 0...


						2.动态分区 “空闲链” ：
							将内存中空闲的分区以 “节点” 的形式存储
							由于各个分区的大小都不一样，“节点” 里需要记录容量

							节点1<=>节点2<=>节点3<=>节点4<=>节点5...

							由于某些节点代表的分区物理上是连续的，就可以合并起来

							节点1<=>节点2~3<=>节点4<=>节点5~6<=>节点7...

					相关算法：

						1.首次适应算法（FF算法）：
								结合 “空闲链” 的数据结构
								分配内存时，从链表头部处顺序查找适合内存区
								若没有找到合适空区区，则该次分配失败
								若找到合适空闲区，则把该区分配给进程使用
								如：
									一个进程需要两个空闲区的大小的内存
									算法就会从链表头部开始顺序遍历，若能找到代表两个连续的分区的
									节点，则返回，把内存分配给进程

								缺点：每一次分配，都是从头部开始，就导致头部的地址空间不断地
									被划分，空间越来越小，产生很多碎片
							
								改良：由于缺点，所以改进出了 “循环适应算法”，该算法每一次分配
									的时候，不是从头部开始遍历，而是从上一次检索结束的位置开始遍历


						2.最佳适应算法（BF算法）：
								结合 “空闲链” 的数据结构
								先把空闲链表按照容量大小排序
								分配内存时，遍历排序后的链表，查找最佳最合适的节点（空闲区）
								如：
									节点1<=>节点2~3<=>节点4<=>节点5~6<=>节点7...
									排序后：
									节点1<=>节点4<=>节点7<=>节点2~3<=>节点5~6

								优点：避免大材小用


						3.快速适应算法（QF算法）：
								结合 “空闲链” 的数据结构
								要求有多个空闲链表来存储空闲分区
								每个空闲链表存储一种容量的空闲区节点
								分配内存时，就可以快速找到合适的空闲区
								如：
									链表1：节点1<=>节点4<=>节点7
									链表2：节点2~3<=>节点5~6