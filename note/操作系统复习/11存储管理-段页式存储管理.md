存储管理-段页式存储管理：


		操作系统是如何管理 “进程的空间” 的呢？

		三种方法：1.页式存储管理 2.段式存储管理	 3.段页式存储管理	
				————不管是哪种管理方法
					本质都是去 “管理进程的内存空间，把进程的内存空间映射到物理的内存空间”




		页面：
			回顾计算机组成原理中的 “字” 的概念，“字” 是相对于 “物理设备” 的定义
			“页面” 则是相对于 “逻辑空间” 的定义
			“字”、“页面”，指的都是一块大小一样的内存



		页式存储管理：
				1.将 “进程的逻辑空间” 分成若干个 “大小相等” 的 “页面”（等分）
				2.相应的把 “物理内存空间” 分成与 “页面大小相等” 的 “物理块(字块)”
				3.以 “页面” 为单位，把 “进程的空间” 装进 “物理内存中分散的物理块(字块)”


				4.内存碎片：
						假设内存中的空闲区链表为：
							节点1<=>节点2~3<=>节点4<=>节点5~6<=>节点7...
						此时一个页面的大小 “大于” 节点1的大小，“小于” 节点2~3的大小
						这个页面只好存储在节点2~3表示的空区区中，这个空闲区存储完这个页面大小后的
						剩余空间就是 “内存碎片”

				——————所以：页面大小应该适中，过大难以分配，过小容易 “内存碎片” 过多

				（一般来说页面大小范围为：512B(字节)~8K(千字节)）



				我们可以把进程的逻辑空间的每一个 “页面” 都存放到内存的 “物理块(字块)” 中，但是我们怎么知
				道 “某一个页面” 存放到 “具体哪一个物理块(字块)” 中呢？
				————页表



				5.页表：
					是记录 “进程逻辑空间页面” 与 “物理空间” 的 “映射”
					如：
						一个进程的逻辑空间分成了：页面1、页面2、页面3、页面4、页面5
						这些页面 “分散的” 存储在内存中的 “物理块(字块)”
						就需要一个表来记录映射关系，如下表：

						页面     字块
						1		  1
						2		  3
						3		  4
						4		  6
						5		  9



				6.页式存储管理的 “地址”：

					地址分为两部分：页号 + 页内偏移
								 （“页号” 相当于 “字块”，“页内偏移” 相当于 字块的 “字内偏移”）


				7.页式存储管理的问题：

					现代计算机中，可以支持非常大的逻辑地址空间（2^32~2^64），这样，页表就变得非常
					大，会占用非常大的内存空间
						如：
							具有32位逻辑地址空间的寻址系统，规定 “页面” 大小为4K
							（32位系统进程的寻址空间为4G，4G/4K=2^20）
							则每个进程 “页表” 中的 “页表项” 可达2^20个（=1M个）
							若每个 “页表项” 占用1Byte
							则每个进程仅 “页表” 就要占用1MB的内存空间

					——————因此出现了 “多级页表”



				8.多级页表：

						有一个 “根页表” 
						该表中每一个 “页面” 对应的 “字块” 指向的地址是内存中的一块空间，这个空间
						存储的是 “二级页表”

						一个 “根页表” 指向多个 “二级页表” 

						“二级页表” 中的页表项的字块指向的才是该进程实际使用的内存物理块

						——————这样就只要把这个 “根页表” 加载到内存里就好了，按实际需求再加载具体
							  某个 “二级页表”，这样就可以节省内存空间


				9.缺点：
					若进程中有一连续的逻辑，按页式存储管理的方式被拆分分布在多个页面，会大大降低执行效率






		段式存储管理：
				1.将 “进程的逻辑空间” 划分成若干 “段”（非等分）
				2.“段” 的长度由连续逻辑的长度决定（如一个主函数MAIN，一个子函数X等）

				3.段表：
					是记录 “进程逻辑空间段” 与 “物理空间” 的 “映射”
						如以下一个段表：
						（每一段的大小都是不一样的）

						段号		基址(起始地址)	段长
						 1			10k			30k
						 2			40k			10k
						 3			50k			40k
						...

				4.段地址：
						分为两部分：段号 + 段内偏移





		“页式存储管理” 与 “段式存储管理” 比较：

				相同点：
					都离散地管理了 “进程的逻辑空间”

				不同点：
					“页” 是从 “物理” 的角度去划分的，是 “物理单位”
					“段” 是从 “进程的逻辑” 的角度去划分的，是 “逻辑单位”

					“页大小” 由 “硬件固定”
					“段长度” 可以 “动态变化”

					“分页” 是为了 “合理利用空间”
					“分段” 是为了 “满足用户需求”

					“页表” 信息是 “一维” 的
					“段表” 信息是 “二维” 的





		段页式存储管理：
				结合了前面两种方式的优点

				页式存储管理分页的优点：可以有效提高内存利用率（虽然存在页内碎片）
				段式存储管理分段的优点：可以满足用户需求（段长根据逻辑长度来，逻辑是用户写的）

				1.先将 “进程的逻辑空间” 按照段式管理分成 “若干段”
				2.再把 “段内空间” 按照页式管理分成 “若干页”
				3.段内地址、业内地址同样都分成两个部分：
					段地址：段号 + 段内偏移
					页地址：页号 + 页内偏移

				4.结合两个地址形成一个地址：
					段页地址：段号 + 段内页号 + 页内地址

					段号：指定 “进程的逻辑空间的具体哪一段”
					段内页号：指定 “段里面具体哪一页”
					页内地址：指定 “某一页对应的具体的字”